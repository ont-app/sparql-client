<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>ont-app.sparql-client.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction to sparql-client</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ont-app</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sparql-client</span></div></div></li><li class="depth-3 branch current"><a href="ont-app.sparql-client.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3"><a href="ont-app.sparql-client.ont.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ont</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="ont-app.sparql-client.core.html#var-count-subjects"><div class="inner"><span>count-subjects</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-client.core.html#var-create-load-context"><div class="inner"><span>create-load-context</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-client.core.html#var-decode-bnode-kwi-name"><div class="inner"><span>decode-bnode-kwi-name</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-client.core.html#var-default-binding-translators"><div class="inner"><span>default-binding-translators</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-client.core.html#var-drop-client.21"><div class="inner"><span>drop-client!</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-client.core.html#var-kwi-for"><div class="inner"><span>kwi-for</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-client.core.html#var-load-rdf-file"><div class="inner"><span>load-rdf-file</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-client.core.html#var-make-sparql-reader"><div class="inner"><span>make-sparql-reader</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-client.core.html#var-make-sparql-updater"><div class="inner"><span>make-sparql-updater</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-client.core.html#var-ontology"><div class="inner"><span>ontology</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-client.core.html#var-prefixed"><div class="inner"><span>prefixed</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-client.core.html#var-property-path"><div class="inner"><span>property-path</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-client.core.html#var-quote-str"><div class="inner"><span>quote-str</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-client.core.html#var-reset-annotation-graph"><div class="inner"><span>reset-annotation-graph</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-client.core.html#var-standard-read-context"><div class="inner"><span>standard-read-context</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-client.core.html#var-standard-write-context"><div class="inner"><span>standard-write-context</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-client.core.html#var-update-endpoint.21"><div class="inner"><span>update-endpoint!</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-client.core.html#var-warn-on-no-ns-metadata-for-kwi.3F"><div class="inner"><span>warn-on-no-ns-metadata-for-kwi?</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">ont-app.sparql-client.core</h1><div class="doc"><pre class="plaintext"></pre></div><div class="public anchor" id="var-count-subjects"><h3>count-subjects</h3><div class="usage"><code>(count-subjects client)</code></div><div class="doc"><pre class="plaintext">Returns the number of subjects at endpoint of  `client`
- Where
  - `client` conforms to  `::sparql-client` spec</pre></div></div><div class="public anchor" id="var-create-load-context"><h3>create-load-context</h3><div class="usage"><code>(create-load-context query-url update-url graph-uri)</code></div><div class="doc"><pre class="plaintext">Returns `io-context` for `query-endpoint` `update-endpoint` `graph-uri`
- Where
  - `query-url` is the URL of the query endpoint of the client
  - `update-url` is the URL of the update endpoint of the client
  - `graph-uri` is a KWI for the URI of the nameed graph associated with the file to
     be loaded by `rdf/load-rdf`
  - `io-context` is a native-normal graph serving as the the first, 'context' argument
     to `rdf/load-rdf` dispatched on [`SparqlUpdater` *]
</pre></div></div><div class="public anchor" id="var-decode-bnode-kwi-name"><h3>decode-bnode-kwi-name</h3><div class="usage"><code>(decode-bnode-kwi-name bkwi)</code></div><div class="doc"><pre class="plaintext">Returns a string description of `bkwi` suitable for embedding in SPARQL
- where
  - `bkwi` is a keyword encoded by (`mint-kwi` `bnode-class`)
  - `bnode` is a bnode annotated and rendered with `render-element`
</pre></div></div><div class="public anchor" id="var-default-binding-translators"><h3>default-binding-translators</h3><div class="usage"><code>(default-binding-translators endpoint-url graph-uri)</code></div><div class="doc"><pre class="plaintext">Binding translators used to simplify bindings. See sparq-endpoint.core
- Wnere
- `endpoint-url` and `graph-uri` are used to mint unique values for bnodes.
</pre></div></div><div class="public anchor" id="var-drop-client.21"><h3>drop-client!</h3><div class="usage"><code>(drop-client! g)</code></div><div class="doc"><pre class="plaintext">Side-effect: the named graph associated with `client` is dropped from its endpoint
</pre></div></div><div class="public anchor" id="var-kwi-for"><h3>kwi-for</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Issues a warning if no ns metadata is found for the URI
</pre></div></div><div class="public anchor" id="var-load-rdf-file"><h3>load-rdf-file</h3><h4 class="type">multimethod</h4><h4 class="deprecated">deprecated</h4><div class="usage"></div><div class="doc"><pre class="plaintext">DEPRECATED. use `rdf/read-rdf` instead
</pre></div></div><div class="public anchor" id="var-make-sparql-reader"><h3>make-sparql-reader</h3><div class="usage"><code>(make-sparql-reader &amp; {:keys [graph-uri query-url binding-translator auth]})</code></div><div class="doc"><pre class="plaintext">Returns an instance of SparqlReader.
- Where
- `graph-uri` is the named graph within the SPARQL endpoint. nil implies DEFAULT
- `query-url` is the query endpoint
- `binding-translator` := {:uri `uri-fn` :lang `lang-fn` :datatype `datatype-fn`}
   default is sparql-endpoint.core/default-translators)
- `auth` (optional)  is the authorization token needed to perform updates
- `uri-fn` := (fn [binding]...) -&gt; URI representation. 
  Default is just the URI string
- `lang-fn` := (fn [binding] ...) -&gt; parsed language tag. 
   Default is just the language string with no
- `datatype-fn` := (fn [binding] -` Parsed datatype
- `binding` := {:value ... 
               :type ... 
                &amp;maybe 
               :xml:lang ... 
               :datatype ...}
   This occurs in bindings of the form {`var` `binding`, ...} returned by a 
    SPARQL query.
- See also sparql-endpoint.core.</pre></div></div><div class="public anchor" id="var-make-sparql-updater"><h3>make-sparql-updater</h3><div class="usage"><code>(make-sparql-updater &amp; {:keys [graph-uri query-url binding-translator update-url auth], :or {binding-translator (default-binding-translators query-url graph-uri)}, :as args})</code></div><div class="doc"><pre class="plaintext">Returns an instance of SparqlUpdater.
- Where
- `graph-uri` is the named graph within the SPARQL endpoint. nil implies DEFAULT
- `query-url` is the query endpoint
- `binding-translator` := {:uri `uri-fn` :lang `lang-fn` :datatype `datatype-fn`}
  default is sparql-endpoint.core/default-translators)
- `update-url` (optional) is update endpoint (or nil if read-only)
- `auth` (optional)  is the authorization token needed to perform updates
- `uri-fn` := (fn [binding]...) -&gt; URI representation. 
  Default is just the URI string
- `lang-fn` := fn [binding] -&gt; parsed language tag. 
   Default is just the language string
- `datatype-fn` := fn [binding] -&gt; Parsed datatype
- `binding` := {:value ... 
              :type ... 
              &amp;maybe 
              :xml:lang ... 
              :datatype ...}
  This occurs in bindings of the form {`var` `binding`, ...} returned by a 
  SPARQL query.
- See also sparql-endpoint.core.</pre></div></div><div class="public anchor" id="var-ontology"><h3>ontology</h3><div class="usage"></div><div class="doc"><pre class="plaintext">A native-normal graph describing the supporting vocabulary for sparql-client
</pre></div></div><div class="public anchor" id="var-prefixed"><h3>prefixed</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Returns `sparql-string`, prepended with appropriate PREFIX decls.
</pre></div></div><div class="public anchor" id="var-property-path"><h3>property-path</h3><div class="usage"><code>(property-path path)</code></div><div class="doc"><pre class="plaintext">Returns a traversal function [g c a q] -` [c a' q'] equivalent to `path`
- Where
  - `path` is a SPARQL property path, e.g. 'myns:prop1/myns:prop2'
  - `g` is an sparql update client
  - `c` is a traversal context
  - `a` is an accumulator (typically a set)
  - `a'` has been conj'ed with the `?o` bindings of `query`
  - `q` is an input queue to the traversal
  - `q'` is the rest of `q`
  - `query` is `query-for-o template`, with (first `q`) as subject and `path`
     as the predicate. This binds a single var `?o`.
</pre></div></div><div class="public anchor" id="var-quote-str"><h3>quote-str</h3><div class="usage"><code>(quote-str s)</code></div><div class="doc"><pre class="plaintext">Returns `s`, in excaped quotation marks.
- Where
  - `s` is a string, typically to be rendered in a query or RDF source.</pre></div></div><div class="public anchor" id="var-reset-annotation-graph"><h3>reset-annotation-graph</h3><div class="usage"><code>(reset-annotation-graph client &amp; {:keys [client-model bnode-query collect-bindings ignore-if], :or {bnode-query query-for-all-bnodes, collect-bindings collect-bnode-query-binding, ignore-if (fn [_ann _clause-type _node _property counterpart] (string? counterpart))}})</code></div><div class="doc"><pre class="plaintext">Returns `client`' annotated for blank nodes so that round-trippable values can be
provided. Overwrites any previous annotations.
- Where
  - `client` is a sparql-client
  - `client-model` is a native-normal graph containing a subgraph of the client's
     graph with triples containing the bnodes we wish to annotate. Optional. Defalt
     will build a new client model from `bnode-query` and `collect-bindings`
  - `bnode-query` is a SPARQL query for the client model. Default is
    `query-for-all-bnodes`
  - `collect-bindings` is a `reduce-spo` function collecting the output of
     `bnode-query` into a new `client-model`
  - `ignore-if` := (fn [ann clause-type node property counterpart] -&gt; truthy when a
    given clause should not inform annotations for bnodes. Referenced in
    `ignore-triple-clause?` function.
</pre></div></div><div class="public anchor" id="var-standard-read-context"><h3>standard-read-context</h3><div class="usage"></div><div class="doc"><pre class="plaintext">The standard context argument to `rdf/read-rdf` dispatched on [`SparqlUpdater` *] and basis for `create-load-context`
</pre></div></div><div class="public anchor" id="var-standard-write-context"><h3>standard-write-context</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Standard 'context' argument to `rdf/write-rdf` for methods dispatched on  [`sparql-client/IGraph` * *]
</pre></div></div><div class="public anchor" id="var-update-endpoint.21"><h3>update-endpoint!</h3><div class="usage"><code>(update-endpoint! client update)</code></div><div class="doc"><pre class="plaintext">Side-effect: `update` is sent to `client`
- Where
  - `update` is a sparql update
  - `client` is a SparqlUpdater</pre></div></div><div class="public anchor" id="var-warn-on-no-ns-metadata-for-kwi.3F"><h3>warn-on-no-ns-metadata-for-kwi?</h3><div class="usage"></div><div class="doc"><pre class="plaintext">True when we should warn if there is no ns metadata found for the URI
being translated into a KWI in `kwi-for`.
</pre></div></div></div></body></html>